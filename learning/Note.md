基本数据类型：

undefined 和 null 是所有类型的子类型，在非严格模式下，undefined 和null 可以赋值给任何类型的变量，但在严格模式下，这样的赋值会报错，因为严格模式下，会进行严格的类型检查

任意值：
一个变量一旦声明为某一类型，那么这个变量就只能被赋予这个类型的值，中间不能再给这个变量赋其他类型的值
而如果我们将变量的类型声明为任意值，那么这个变量可以被赋值为多种不同类型的值，就像js中的变量一样，可以被赋予不同的值
如果定义的时候没有指明变量的类型，也没有给该变量赋值，那么这个变量的类型就会被推断为any从而可以接受任意类型的值


类型推论
如果在声明一个变量时，没有指明该变量的类型，那么ts会根据给这个变量赋的值来进行类型推断，从而给该变量指定类型， 类型推论指定之后，再给这个变量赋予其他类型的值则会报错
赋值没有指定类型则会进行类型推断，从而确定类型
没有赋值则该变量的类型就不确定 为any

**如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：

联合类型
 | 来表示这个变量的类型可以是多个类型中的任意一种类型，也就是说只要是声明的联合类型中的类型，那么这个变量就可以被赋予相应的值
 当我们不确定一个联合类型的变量到底表示是哪一种类型时，我们只能访问此联合类型中所有类型里共有的属性或方法


 接口（interface）
 用来在声明对象时，明确对象的类型，明确这个对象内的属性可能都有什么，其实就是相当于js中的构造函数，只不过ts里面是接口，而且这个接口中属性的特性存在一些特殊性
 接口中的属性有：
    * 确定属性： 属性名，属性值的类型都是明确的
    * 可选属性： 这个属性在变量中，可以出现也可以不出现，是一个可选的
    * 任意属性： 变量中可以出现自己自定义的属性，但是这个自定属性的属性名的类型和属性值的类型要符合接口中的定义，最重要的一点是，一个接口中只能定一个任意属性， 且确定属性与可选属性的值的类型要是任意属性值的子类，否则会报错，例如 任意类型的值的类型时string
    ，那么确定属性和可选属性的值的类型也只能是string。通常任意属性的值是不确定的，所以通常任意属性的值的类型都用联合类型来表示
    *只读属性：用readonly 来声明接口中的这个属性是只读属性，只读属性的要求：创建对象或变量时只读属性必须要被赋值，并且只读属性的值在之后也不能被改变

数组：
   数组声明的方式：
      类型 + 方括号    let arr : number[]
      数组泛型         let arr : Array<number>
      类数组    通过接口来表示为数组，需要用到任意属性
   类数组  与js中的set，map一样就是看起来像是数组，但本质上并不是数组
   any 如果将数组的类型申明为any，那么该数组中能够存放任何的值

函数：
   函数的表达方式： 函数声明，函数表达式
   函数中的参数：
       必须参数： 调用函数时必须要传递的参数，且传递的必须参数的个数不能多也不能少
       可选参数：与可选属性的声明方式一致，只能放在必须参数之后，否则报错
       默认参数： 给参数设置默认值，ts会把默认参数看作为可选参数，但是默认参数可以方在必修参数之前，因为默认参数就算不传递值也是有值的
       剩余参数: 其实就是js中的...参数, 与js中的写法一样，但就是要声明类型，类型要声明为某一中类型的数组，或任意类型数组
   重载：
      和java中的重载一样，函数名相同，但是函数的参数个数，参数类型，函数的返回值类型不同，所以函数不同，会根据调用函数时具体的参数的个数和参数类型来决定使用哪一个具体的函数，
      ts会从最前面定义的函数开始匹配，因此越精确的函数应该放在越前面的地方
